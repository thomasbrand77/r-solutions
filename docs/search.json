[
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html",
    "href": "posts/makepipe-and-rmarkdown/index.html",
    "title": "Using rmarkdown with makepipe",
    "section": "",
    "text": "In this blog I will demonstrate how you can use makepipe with Rmd-files, so that the dependencies (i.e. the necessary inputs of the workflow within the Rmd) and targets (i.e. the generated outputs of the workflow within the Rmd) don’t have to be known in advance, but are generated by using the exact same code that is used by the Rmd."
  },
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html#standard-workflow-in-data-science",
    "href": "posts/makepipe-and-rmarkdown/index.html#standard-workflow-in-data-science",
    "title": "Using rmarkdown with makepipe",
    "section": "Standard workflow in data science",
    "text": "Standard workflow in data science\nData science workflows often consists of serveral scripts or functions that have to be executed in a certain order because they depend on one another. That means you have\n\none or more inputs (often data files which are generated by some batch, downloaded or created manually)\none or several outputs (these are the results of your computations and you write them to disk als CSV, XLSX, Rdata or parquet, just to name a few options)"
  },
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html#what-does-makepipe-has-to-offer",
    "href": "posts/makepipe-and-rmarkdown/index.html#what-does-makepipe-has-to-offer",
    "title": "Using rmarkdown with makepipe",
    "section": "What does makepipe has to offer",
    "text": "What does makepipe has to offer\n\n\n\n\n\n\nTip\n\n\n\nFor a detailed description of what you can do with makepipe developed by Kinto Behr please go to\nBehr K (2025). makepipe: Pipeline Tools Inspired by ‘GNU Make’. R package version 0.2.2, https://github.com/kinto-b/makepipe, https://kinto-b.github.io/makepipe/.\n\n\nWe will use the function makepipe::make_with_source to start a simple R-script that will read in some data, do a little processing and writing an output to disk. In order to do this the make_wih_source-function will need three attributes\n\nsource i.e. the R-script\ntargets i.e. the output-file\ndependencies i.e. the input-file\n\nSo, our R-script will look like this:\n\nlibrary(data.table)\n\n# read data\ndt = fread(\"./one_input.csv\")\n\n# process data\ndt[, new_col := 1L]\n\n# write data\nfwrite(dt, file = \"./one_output.csv\")\n\nIn addition we have another script with has to run after one_source.R` because it’s input is the output of the first script.\n\nlibrary(data.table)\n\n# read data\ndt = fread(\"./one_output.csv\")\n\n# process data\ndt[, newer_col := 2L]\n\n# write data\nfwrite(dt, file = \"./two_output.csv\")"
  },
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html#a-simple-example",
    "href": "posts/makepipe-and-rmarkdown/index.html#a-simple-example",
    "title": "Using rmarkdown with makepipe",
    "section": "A simple example",
    "text": "A simple example\nLets build a pipeline with theese two scripts\n\nlibrary(makepipe)\n\n# first script\nmake_with_source(source = \"./one_source.R\",\n                 note = \"first script to run\",\n                 targets = \"./one_output.csv\",\n                 dependencies = \"./one_input.csv\")\n\n# second script\nmake_with_source(source = \"./two_source.R\",\n                 note = \"second script to run\",\n                 targets = \"./two_output.csv\",\n                 dependencies = \"./one_output.csv\")\n\nshow_pipeline(as = \"visnetwork\")\n\n\n\n\nDemo Pipeline with dependencies\n\n\nAs you can see all the r-scripts are run and the outputs are produced. If you run the pipeline a second time nothing will be done because alle targets are up-to-date.\nLets delete two_output.csv and look at the visualisation of the pipeline\n\n\n\nDemo Pipeline partially invalidated\n\n\nIf we now run the pipeline again\n\np = get_pipeline()\np$build()\n\n✔ Targets are up to date\n✔ Targets are up to date\n\n\nonly the second R-script is run and all targets are up-to-date again\n\n\n\nDemo Pipeline up-to-date again"
  },
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html#problem-definition",
    "href": "posts/makepipe-and-rmarkdown/index.html#problem-definition",
    "title": "Using rmarkdown with makepipe",
    "section": "Problem definition",
    "text": "Problem definition\nMost Rmarkdown-files (especially parametrisized Rmd-files) are in itself a kind of mini-pipeline, that is:\n\nYou have an input e.g.\n\na file-path for the input files or\na string by which the input file-paths are constructed;\n\nYou have several steps in your Rmd, e.g.\n\nread input data\nprocess data\ncalculate results\nwrite results to disk\n\n\nWith this in mind our Rmd-File could look like that:\n\n\n---\ntitle: \"RmdScript1\"\nparams:\n  input: \"./input.csv\" \n  output: \"./output.Rdata\"\nauthor: \"Thomas Brand\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(rlang)\nlibrary(data.table)\n```\n\n# setup inputs and outputs\n\n```{r get-inputs}\ninputs = list()\ninputs = append(inputs,\n                params$input %||% \"./default_input.csv\")\n```\n\n```{r get-outputs}\n\noutputs = list()\noutputs = append(outputs,\n                 params$output %||% \"./default_output.Rdata\")\n\n```\n\n# do some stuff\n\n## read data\n\n```{r read-data}\n\ndt = fread(inputs[[1]])\n```\n\n## manipulate data\n\n```{r manipulate-data}\n\ndt[, colDate := Sys.Date()]\n\n```\n\n# write output\n\n```{r write-output}\n\nsave(dt, file = outputs[[1]])\n```\n\n\nIn order to use make_with_source or to be precise make_with_recipe (as Rmd is not an r-script) you could declare the params$input and params$output as your dependencies and targets that you pass on to the params attribute in the rmarkdown::render function, i.e\n\nrmarkdown::render(input = \"./RmdScript.Rmd\",\n                  output_file = \"./RmdScript_report.html\",\n                  params = list(input = \"input.csv\",\n                                output = \"output.Rdata\"))\n\nThus we would have something like this\n\ninfile = \"one_input.csv\"\noutfile = \"output.Rdata\"\n\nmake_with_recipe(\n  label = \"Render Rmd\",\n  note = \"the code to render the Rmd\",\n  recipe = {\n    rmarkdown::render(input = \"./RmdScript.Rmd\",\n                      output_file = \"./RmdScript_report.html\",\n                      params = list(input = infile,\n                                    output = outfile))\n  },\n  dependencies = infile,\n  targets = outfile,\n)\n\n\n\n\n\n\n\nNote\n\n\n\nPlease be aware that our target is not the rendered html-file of the Rmd, but an Rdata, that is written to disk by the Rmd. The html-file is just used as a protocol-file.\n\n\nIt would work, but is in my opinion cumbersome and, bare in mind, you would extract part of the logic of your mini-pipeline out of the Rmd-File.\nAnd sometimes you would like to construct the filenames of the input- and output-files within your Rmd and just give a basename in the params, e.g.\n\n\n---\ntitle: \"RmdScript1\"\nparams:\n  basename: NULL\nauthor: \"Thomas Brand\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(rlang)\nlibrary(data.table)\n\nbasename = params$basename %||% \"myfile\"\n```\n\n# setup inputs and outputs\n\n```{r get-inputs}\ninputs = list()\ninputs = append(inputs,\n                paste0(\"./\",basename,\".csv\"))\n```\n\n```{r get-outputs}\n\noutputs = list()\noutputs = append(outputs,\n                paste0(\"./\",basename,\".Rdata\"))\n\n```\n\n# do some stuff\n\n## read data\n\n```{r read-data}\n\ndt = fread(inputs[[1]])\n```\n\n## manipulate data\n\n```{r manipulate-data}\n\ndt[, colDate := Sys.Date()]\n\n```\n\n# write output\n\n```{r write-output}\n\nsave(dt, file = outputs[[1]])\n```"
  },
  {
    "objectID": "posts/makepipe-and-rmarkdown/index.html#solution",
    "href": "posts/makepipe-and-rmarkdown/index.html#solution",
    "title": "Using rmarkdown with makepipe",
    "section": "Solution",
    "text": "Solution\nLet’s think of the chunks of an Rmd-File as Code-snippets, that we can evaluate and that produce certain values/variables. Ideally in the Rmd there is a chunk that will define all the input-files that are used in the Rmd and put them in a list called inputs . These will be our dependencies. The same goes for our outputs (targets) that are in a list called outputs.\nWe want to extract from the Rmd\n\nthe YAML-Header for the params ,\nthe setup- chunk to get all the necessary packages that are used,\nthe get-inputs - chunk to get the code to know the input-files and\nthe get-outputs - chunk to get the code to know the output-files.\n\nIn order to do this we’ll have to build the Rmd with these chunk-names and make sure that they produce the afore mentioned lists.\nAfter that we can execute the chunks in the correct order in a separate environment with the params - list of the YAML-header and extract the necessary variables.\n\nPackage parsermd\n\n\n\n\n\n\nTip\n\n\n\nFor a detailed description of what you can do with parsermd developed by Colin Rundel please go to\nRundel C (2024). parsermd: Formal Parser and Related Tools for R Markdown Documents. R package version 0.2.0, https://github.com/rundel/parsermd, https://rundel.github.io/parsermd/.\n\n\n\n\n\n\n\n\nNote\n\n\n\nWe are using version 0.1.3 of parsermd, so we can’ use YAML-style chunk-options and will use the “classic” chunk-options-form!\n\n\nWhat we intend to do will be taken care of by the parsermd-package. From this package we will need the functions\n\nparse_rmd to get the list of the chunks of the Rmd\nrmd_select to extract just certain chunks\nrmd_source to run a set of chunks\n\nThe necessary code can look like this\n\nlibrary(parsermd)\n\n# get the chunks of our Rmd\nrmd = parse_rmd(rmd = \"./RmdScript.Rmd\")\n\n# select just the named chunks, that we will use\nrmdIO = rmd_select(rmd, \"setup\", \"get-inputs\", \"get-outputs\")\n\n# set up an environment in which we will execute the chunks\nenvIO = new.env()\n\n# extract the params-list of the YAML an put in into the environment\nenvIO$params = rmd_select(rmd,has_type(\"rmd_yaml_list\"))[[1]]$params\n\n# execute the selected code-chunks in the generated environment\nrmd_source(rmdIO, local = envIO)\n\n# extract the input ans output-files to get the targets and dependencies\ninput = unlist(envIO$inputs)\noutputs = unlist(envIO$outputs)\n\n\n\n\n\n\n\nNote\n\n\n\nSometimes you have some variables in the params of your YAML, that you wouldn’t explicitly set in your render-function because they are default values and just could be changed but wouldn’t be changed most times that you run that Rmd. You can do this with the function list_modify of the purrr-package\n\nlibrary(purrr)\nl1 = list(a = 1,\n          b = \"1\",\n          c = 1:3)\n\nl2 = list(b = \"b\",\n          d = 4:5)\n\ncombined_list = list_modify(l1, !!!l2)\ncombined_list\n\n$a\n[1] 1\n\n$b\n[1] \"b\"\n\n$c\n[1] 1 2 3\n\n$d\n[1] 4 5\n\n\n\n\n\n\nLet’s put it all together\nWith this knowledge let’s construct a pipeline for the Rmd where we give just the basename as params.\n\nlibrary(parsermd)\n\nRmd_scriptname = \"./RmdScript_basename.Rmd\"\n\n# get the chunks of our Rmd\nrmd = parse_rmd(rmd = Rmd_scriptname)\n\n# select just the named chunks, that we will use\nrmdIO = rmd_select(rmd, \"setup\", \"get-inputs\", \"get-outputs\")\n\n# set up an environment in which we will execute the chunks\nenvIO = new.env()\n\n# generate the params that we will use to render the Rmd and put them into the environment\nparams = list(basename = \"one_input\")\nenvIO$params = params\n\n# execute the selected code-chunks in the generated environment\nrmd_source(rmdIO, local = envIO)\n\n# extract the input ans output-files to get the targets and dependencies\ninputs = unlist(envIO$inputs)\noutputs = unlist(envIO$outputs)\n\n# construct the pipeline\nmake_with_recipe(\n  label = \"Render Rmd\",\n  note = \"the code to render the Rmd\",\n  recipe = {\n    rmarkdown::render(input = Rmd_scriptname,\n                      output_file = \"./RmdScript_report.html\",\n                      params = params)\n  },\n  dependencies = inputs,\n  targets = outputs,\n)\n\nHere we have\n\nput the params for rendering the Rmd into an environment\nrun the chunks setup, get-inputs, get-outputs in that environment\nextracted the inputs - and outputs -lists from the environment and\ndeclared them as dependencies and targets of our piece of pipeline.\n\nIt just required to build your Rmds according to a certain template, which in my mind isn’t such a bad idea as it helps your future-self to make sense of the Rmds you have written more easily."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "r-solutions",
    "section": "",
    "text": "Using rmarkdown with makepipe\n\n\n\n\n\n\nnews\n\n\ncode\n\n\nmakepipe\n\n\nrmarkdown\n\n\nparsermd\n\n\n\n\n\n\n\n\n\nMay 22, 2025\n\n\nThomas Brand\n\n\n\n\n\n\nNo matching items\n\nReuseCC BY-SA 4.0"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hi, I’m a mathematician and like to work with R. Whenever I have a professional problem I first try to find a solution with R.\nIn these blog posts I’d like to share some of my solutions I developed in R for different problems and in doing this I hope to give you some valuable hints for your work."
  },
  {
    "objectID": "about.html#education-and-experience",
    "href": "about.html#education-and-experience",
    "title": "About",
    "section": "Education and Experience",
    "text": "Education and Experience\nYou can find out more about my professional career on my LinkedIn-page."
  },
  {
    "objectID": "posts/using foverlaps for time-slices/index.html",
    "href": "posts/using foverlaps for time-slices/index.html",
    "title": "using overlaps for time-slices",
    "section": "",
    "text": "Abstract\n\n\nProblem definition\nIn customer/client databases it is often the case that each row in a table has a validity from one date startDate to another date endDate. You have to interpret this row so that the information that are contained in other columns of this row are valid just from startDate to endDate.\nThese rows are referred to as time-slices.\n\n\n\n\n\n\nNote\n\n\n\nAs an indication of time-slice without end (i.e. the end isn’t known by now) you normally use a date far in the future, e.g. 9999-12-31.\nIt is as well useful for joining operations and calulations, that the endDate corresponds to the first Date where the slice isn’t valid any more. In this way you can stitch together the slices of a person by the corresponding startDate to an endDate.\n\n\nLet’s look at some example-data.\n\n\n   client   plan  startDate    endDate basicPrice discount toPayPerMonth\n   &lt;char&gt; &lt;char&gt;     &lt;Date&gt;     &lt;Date&gt;      &lt;num&gt;    &lt;num&gt;         &lt;num&gt;\n1:      A     T1 2024-07-01 9999-12-31      12.34    -0.34         12.00\n2:      B     T1 2024-11-01 2025-03-01      23.45    -1.45         22.00\n3:      B     T2 2025-03-01 9999-12-31      34.56     0.00         34.56\n4:      C     T2 2024-08-01 2025-01-01      14.79    -3.79         11.00\n\n\nThis is of course a simplified example.\nOur task will be to calculate the cumulative payments per plan for each month from July 2024 to June 2025. For this one possible solution would be to generate one line per costumer for each plan and each month.\n\n\nSolution\nFirst, we will generate a data.table with two columns for the begin and the end of an interval. This can be done with the following code.\n\nintervals = data.table(startDate = seq(as.Date(\"2024-09-01\"), to = as.Date(\"2025-06-01\"), by = \"month\"))\nintervals[,endDate := shift(startDate, type = \"lead\")]\nintervals = na.omit(intervals)\ncols = c(\"startDate\",\"endDate\")\nsetkeyv(intervals, cols)\nintervals\n\nKey: &lt;startDate, endDate&gt;\n    startDate    endDate\n       &lt;Date&gt;     &lt;Date&gt;\n1: 2024-09-01 2024-10-01\n2: 2024-10-01 2024-11-01\n3: 2024-11-01 2024-12-01\n4: 2024-12-01 2025-01-01\n5: 2025-01-01 2025-02-01\n6: 2025-02-01 2025-03-01\n7: 2025-03-01 2025-04-01\n8: 2025-04-01 2025-05-01\n9: 2025-05-01 2025-06-01\n\n\nNext we will start a first try to sse what foverlaps will produce.\n\nresult = foverlaps(dt, intervals, by.x = cols, by.y = cols)\nknitr::kable(result)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nstartDate\nendDate\nclient\nplan\ni.startDate\ni.endDate\nbasicPrice\ndiscount\ntoPayPerMonth\n\n\n\n\n2024-09-01\n2024-10-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2024-10-01\n2024-11-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2024-11-01\n2024-12-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2024-12-01\n2025-01-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2025-01-01\n2025-02-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2025-02-01\n2025-03-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2025-03-01\n2025-04-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2025-04-01\n2025-05-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2025-05-01\n2025-06-01\nA\nT1\n2024-07-01\n9999-12-31\n12.34\n-0.34\n12.00\n\n\n2024-10-01\n2024-11-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2024-11-01\n2024-12-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2024-12-01\n2025-01-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2025-01-01\n2025-02-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2025-02-01\n2025-03-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2025-03-01\n2025-04-01\nB\nT1\n2024-11-01\n2025-03-01\n23.45\n-1.45\n22.00\n\n\n2025-02-01\n2025-03-01\nB\nT2\n2025-03-01\n9999-12-31\n34.56\n0.00\n34.56\n\n\n2025-03-01\n2025-04-01\nB\nT2\n2025-03-01\n9999-12-31\n34.56\n0.00\n34.56\n\n\n2025-04-01\n2025-05-01\nB\nT2\n2025-03-01\n9999-12-31\n34.56\n0.00\n34.56\n\n\n2025-05-01\n2025-06-01\nB\nT2\n2025-03-01\n9999-12-31\n34.56\n0.00\n34.56\n\n\n2024-09-01\n2024-10-01\nC\nT2\n2024-08-01\n2025-01-01\n14.79\n-3.79\n11.00\n\n\n2024-10-01\n2024-11-01\nC\nT2\n2024-08-01\n2025-01-01\n14.79\n-3.79\n11.00\n\n\n2024-11-01\n2024-12-01\nC\nT2\n2024-08-01\n2025-01-01\n14.79\n-3.79\n11.00\n\n\n2024-12-01\n2025-01-01\nC\nT2\n2024-08-01\n2025-01-01\n14.79\n-3.79\n11.00\n\n\n2025-01-01\n2025-02-01\nC\nT2\n2024-08-01\n2025-01-01\n14.79\n-3.79\n11.00\n\n\n\n\n\nWe are almost there.\nBut if we look closer we see that there are some wrong lines\n\nresult[c(15,16,24)]\n\n    startDate    endDate client   plan i.startDate  i.endDate basicPrice\n       &lt;Date&gt;     &lt;Date&gt; &lt;char&gt; &lt;char&gt;      &lt;Date&gt;     &lt;Date&gt;      &lt;num&gt;\n1: 2025-03-01 2025-04-01      B     T1  2024-11-01 2025-03-01      23.45\n2: 2025-02-01 2025-03-01      B     T2  2025-03-01 9999-12-31      34.56\n3: 2025-01-01 2025-02-01      C     T2  2024-08-01 2025-01-01      14.79\n   discount toPayPerMonth\n      &lt;num&gt;         &lt;num&gt;\n1:    -1.45         22.00\n2:     0.00         34.56\n3:    -3.79         11.00\n\n\nComparing startDate and endDate with i.startDate an i.endDate we can see the foverlaps generated one line for the month, but that the current intervals ended the month before or didn’t even have started.\n\n\n\n\nReuseCC BY-SA 4.0"
  }
]