{
  "hash": "f59b969f9c22fefaf3537296a5ac0b03",
  "result": {
    "markdown": "---\ntitle: \"Using rmarkdown with makepipe\"\nauthor: \"Thomas Brand\"\ndate: \"2025-05-22\"\ncategories: [news, code, makepipe, rmarkdown, parsermd]\n---\n\n\n# Abstract\n\nIn this blog I will demonstrate how you can use makepipe with Rmd-files, so that the dependencies (i.e. the necessary inputs of the workflow within the Rmd) and targets (i.e. the generated outputs of the workflow within the Rmd) don't have to be known in advance, but are generated by using the exact same code that is used by the Rmd.\n\n# Short reminder what makepipe is all about\n\n## Standard workflow in data science\n\nData science workflows often consists of serveral scripts or functions that have to be executed in a certain order because they depend on one another. That means you have\n\n-   one or more inputs (often data files which are generated by some batch, downloaded or created manually)\n\n-   one or several outputs (these are the results of your computations and you write them to disk als CSV, XLSX, Rdata or parquet, just to name a few options)\n\n## What does makepipe has to offer\n\n::: callout-tip\nFor a detailed description of what you can do with [makepipe](https://kinto-b.github.io/makepipe/index.html) developed by Kinto Behr please go to\n\nBehr K (2025). *makepipe: Pipeline Tools Inspired by 'GNU Make'*. R package version 0.2.2, https://github.com/kinto-b/makepipe, <https://kinto-b.github.io/makepipe/>.\n:::\n\nWe will use the function [makepipe::make_with_source](https://kinto-b.github.io/makepipe/reference/make_with_source.html) to start a simple R-script that will read in some data, do a little processing and writing an output to disk. In order to do this the make_wih_source-function will need three attributes\n\n-   `source` i.e. the R-script\n\n-   `targets` i.e. the output-file\n\n-   `dependencies` i.e. the input-file\n\nSo, our R-script will look like this:\n\n\n::: {.cell file='one_source.R'}\n\n```{.r .cell-code}\nlibrary(data.table)\n\n# read data\ndt = fread(\"./one_input.csv\")\n\n# process data\ndt[, new_col := 1L]\n\n# write data\nfwrite(dt, file = \"./one_output.csv\")\n```\n:::\n\n\nIn addition we have another script with has to run after `one_source.R`\\` because it's input is the output of the first script.\n\n\n::: {.cell file='two_source.R'}\n\n```{.r .cell-code}\nlibrary(data.table)\n\n# read data\ndt = fread(\"./one_output.csv\")\n\n# process data\ndt[, newer_col := 2L]\n\n# write data\nfwrite(dt, file = \"./two_output.csv\")\n```\n:::\n\n\n## A simple example\n\nLets build a pipeline with theese two scripts\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(makepipe)\n\n# first script\nmake_with_source(source = \"./one_source.R\",\n                 note = \"first script to run\",\n                 targets = \"./one_output.csv\",\n                 dependencies = \"./one_input.csv\")\n\n# second script\nmake_with_source(source = \"./two_source.R\",\n                 note = \"second script to run\",\n                 targets = \"./two_output.csv\",\n                 dependencies = \"./one_output.csv\")\n\nshow_pipeline(as = \"visnetwork\")\n```\n:::\n\n\n![Demo Pipeline with dependencies](demo_pipeline.png)\n\nAs you can see all the r-scripts are run and the outputs are produced. If you run the pipeline a second time nothing will be done because alle targets are up-to-date.\n\nLets delete two_output.csv and look at the visualisation of the pipeline\n\n![Demo Pipeline partially invalidated](demo_pipeline_invalidated.png)\n\nIf we now run the pipeline again\n\n\n::: {.cell}\n\n```{.r .cell-code}\np = get_pipeline()\np$build()\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n✔ Targets are up to date\n✔ Targets are up to date\n```\n:::\n:::\n\n\nonly the second R-script is run and all targets are up-to-date again\n\n![Demo Pipeline up-to-date again](demo_pipeline_up-to-date.png)\n\n# How can makepipe work with rmarkdown\n\n## Problem definition\n\nMost Rmarkdown-files (especially parametrisized Rmd-files) are in itself a kind of mini-pipeline, that is:\n\n-   You have an input e.g.\n\n    -   a file-path for the input files or\n\n    -   a string by which the input file-paths are constructed;\n\n-   You have several steps in your Rmd, e.g.\n\n    -   read input data\n\n    -   process data\n\n    -   calculate results\n\n    -   write results to disk\n\nWith this in mind our Rmd-File could look like that:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n````{.sourceCode .r}\n---\ntitle: \"RmdScript1\"\nparams:\n  input: \"./input.csv\" \n  output: \"./output.Rdata\"\nauthor: \"Thomas Brand\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(rlang)\nlibrary(data.table)\n```\n\n# setup inputs and outputs\n\n```{r get-inputs}\ninputs = list()\ninputs = append(inputs,\n                params$input %||% \"./default_input.csv\")\n```\n\n```{r get-outputs}\n\noutputs = list()\noutputs = append(outputs,\n                 params$output %||% \"./default_output.Rdata\")\n\n```\n\n# do some stuff\n\n## read data\n\n```{r read-data}\n\ndt = fread(inputs[[1]])\n```\n\n## manipulate data\n\n```{r manipulate-data}\n\ndt[, colDate := Sys.Date()]\n\n```\n\n# write output\n\n```{r write-output}\n\nsave(dt, file = outputs[[1]])\n```\n````\n:::\n:::\n\n\nIn order to use `make_with_source` or to be precise [make_with_recipe](https://kinto-b.github.io/makepipe/reference/make_with_recipe.html) (as Rmd is not an r-script) you could declare the `params$input` and `params$output` as your `dependencies` and `targets` that you pass on to the `params` attribute in the `rmarkdown::render` function, i.e\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrmarkdown::render(input = \"./RmdScript.Rmd\",\n                  output_file = \"./RmdScript_report.html\",\n                  params = list(input = \"input.csv\",\n                                output = \"output.Rdata\"))\n```\n:::\n\n\nThus we would have something like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninfile = \"one_input.csv\"\noutfile = \"output.Rdata\"\n\nmake_with_recipe(\n  label = \"Render Rmd\",\n  note = \"the code to render the Rmd\",\n  recipe = {\n    rmarkdown::render(input = \"./RmdScript.Rmd\",\n                      output_file = \"./RmdScript_report.html\",\n                      params = list(input = infile,\n                                    output = outfile))\n  },\n  dependencies = infile,\n  targets = outfile,\n)\n```\n:::\n\n\n::: callout-note\nPlease be aware that our target is not the rendered html-file of the Rmd, but an Rdata, that is written to disk by the Rmd. The html-file is just used as a protocol-file.\n:::\n\nIt would work, but is in my opinion cumbersome and, bare in mind, you would extract part of the logic of your mini-pipeline out of the Rmd-File.\n\nAnd sometimes you would like to construct the filenames of the input- and output-files within your Rmd and just give a basename in the params, e.g.\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n````{.sourceCode .r}\n---\ntitle: \"RmdScript1\"\nparams:\n  basename: NULL\nauthor: \"Thomas Brand\"\ndate: \"`r Sys.Date()`\"\noutput: html_document\n---\n\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = TRUE)\nlibrary(rlang)\nlibrary(data.table)\n\nbasename = params$basename %||% \"myfile\"\n```\n\n# setup inputs and outputs\n\n```{r get-inputs}\ninputs = list()\ninputs = append(inputs,\n                paste0(\"./\",basename,\".csv\"))\n```\n\n```{r get-outputs}\n\noutputs = list()\noutputs = append(outputs,\n                paste0(\"./\",basename,\".Rdata\"))\n\n```\n\n# do some stuff\n\n## read data\n\n```{r read-data}\n\ndt = fread(inputs[[1]])\n```\n\n## manipulate data\n\n```{r manipulate-data}\n\ndt[, colDate := Sys.Date()]\n\n```\n\n# write output\n\n```{r write-output}\n\nsave(dt, file = outputs[[1]])\n```\n````\n:::\n:::\n\n\n## Solution\n\nLet's think of the chunks of an Rmd-File as Code-snippets, that we can evaluate and that produce certain values/variables. Ideally in the Rmd there is a chunk that will define all the input-files that are used in the Rmd and put them in a list called `inputs` . These will be our `dependencies`. The same goes for our outputs (`targets`) that are in a list called `outputs`.\n\nWe want to extract from the Rmd\n\n-   the YAML-Header for the `params` ,\n\n-   the `setup`- chunk to get all the necessary packages that are used,\n\n-   the `get-inputs` - chunk to get the code to know the input-files and\n\n-   the `get-outputs` - chunk to get the code to know the output-files.\n\nIn order to do this we'll have to build the Rmd with these chunk-names and make sure that they produce the afore mentioned lists.\n\nAfter that we can execute the chunks in the correct order in a separate environment with the `params` - list of the YAML-header and extract the necessary variables.\n\n### Package parsermd\n\n::: callout-tip\nFor a detailed description of what you can do with [parsermd](https://rundel.github.io/parsermd/index.html) developed by Colin Rundel please go to\n\nRundel C (2024). *parsermd: Formal Parser and Related Tools for R Markdown Documents*. R package version 0.2.0, https://github.com/rundel/parsermd, <https://rundel.github.io/parsermd/>.\n:::\n\n::: callout-note\nWe are using version 0.1.3 of parsermd, so we can' use YAML-style chunk-options and will use the \"classic\" chunk-options-form!\n:::\n\nWhat we intend to do will be taken care of by the parsermd-package. From this package we will need the functions\n\n-   [parse_rmd](https://rundel.github.io/parsermd/reference/parse_rmd.html) to get the list of the chunks of the Rmd\n\n-   [rmd_select](https://rundel.github.io/parsermd/reference/rmd_select.html) to extract just certain chunks\n\n-   [rmd_source](https://rundel.github.io/parsermd/reference/rmd_source.html) to run a set of chunks\n\nThe necessary code can look like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parsermd)\n\n# get the chunks of our Rmd\nrmd = parse_rmd(rmd = \"./RmdScript.Rmd\")\n\n# select just the named chunks, that we will use\nrmdIO = rmd_select(rmd, \"setup\", \"get-inputs\", \"get-outputs\")\n\n# set up an environment in which we will execute the chunks\nenvIO = new.env()\n\n# extract the params-list of the YAML an put in into the environment\nenvIO$params = rmd_select(rmd,has_type(\"rmd_yaml_list\"))[[1]]$params\n\n# execute the selected code-chunks in the generated environment\nrmd_source(rmdIO, local = envIO)\n\n# extract the input ans output-files to get the targets and dependencies\ninput = unlist(envIO$inputs)\noutputs = unlist(envIO$outputs)\n```\n:::\n\n\n::: callout-note\nSometimes you have some variables in the params of your YAML, that you wouldn't explicitly set in your render-function because they are default values and just could be changed but wouldn't be changed most times that you run that Rmd. You can do this with the function [list_modify](https://purrr.tidyverse.org/reference/list_assign.html) of the [purrr-package](https://purrr.tidyverse.org/index.html)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(purrr)\nl1 = list(a = 1,\n          b = \"1\",\n          c = 1:3)\n\nl2 = list(b = \"b\",\n          d = 4:5)\n\ncombined_list = list_modify(l1, !!!l2)\ncombined_list\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n$a\n[1] 1\n\n$b\n[1] \"b\"\n\n$c\n[1] 1 2 3\n\n$d\n[1] 4 5\n```\n:::\n:::\n\n:::\n\n### Let's put it all together\n\nWith this knowledge let's construct a pipeline for the Rmd where we give just the basename as params.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parsermd)\n\nRmd_scriptname = \"./RmdScript_basename.Rmd\"\n\n# get the chunks of our Rmd\nrmd = parse_rmd(rmd = Rmd_scriptname)\n\n# select just the named chunks, that we will use\nrmdIO = rmd_select(rmd, \"setup\", \"get-inputs\", \"get-outputs\")\n\n# set up an environment in which we will execute the chunks\nenvIO = new.env()\n\n# generate the params that we will use to render the Rmd and put them into the environment\nparams = list(basename = \"one_input\")\nenvIO$params = params\n\n# execute the selected code-chunks in the generated environment\nrmd_source(rmdIO, local = envIO)\n\n# extract the input ans output-files to get the targets and dependencies\ninputs = unlist(envIO$inputs)\noutputs = unlist(envIO$outputs)\n\n# construct the pipeline\nmake_with_recipe(\n  label = \"Render Rmd\",\n  note = \"the code to render the Rmd\",\n  recipe = {\n    rmarkdown::render(input = Rmd_scriptname,\n                      output_file = \"./RmdScript_report.html\",\n                      params = params)\n  },\n  dependencies = inputs,\n  targets = outputs,\n)\n```\n:::\n\n\nHere we have\n\n-   put the params for rendering the Rmd into an environment\n\n-   run the chunks `setup`, `get-inputs`, `get-outputs` in that environment\n\n-   extracted the `inputs` - and `outputs` -lists from the environment and\n\n-   declared them as `dependencies` and `targets` of our piece of pipeline.\n\nIt just required to build your Rmds according to a certain template, which in my mind isn't such a bad idea as it helps your future-self to make sense of the Rmds you have written more easily.\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}