{
  "hash": "fc468316b3e056b4e1181135713b3651",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"using-fread-for-reading-csv\"\nauthor: \"Thomas Brand\"\ndate: \"2025-07-26\"\ncategories: [news, code, data.table, fread]\ndraft: false\n---\n\n# Abstract\n\nIn this blog I will show you how you can use the fread-function of the data.table-package to read in csv-files which don't adhere to certain standards for csv-files. For this I recommend using a predefined table of structure-information of the csv to read in, which will be used in a function to read in the csv via fread and then convert the data into the correct types.\n\n![](picture.png)\n\n# Use case\n\nImagine we have to read a csv-file into R in order analyze the data further.\n\nBesides the functions\n\n-   `read.csv()` from the utils-package,\n\n-   `read_csv()` from the [readr](https://readr.tidyverse.org)-package\n\n-   `duckdb_read_csv()` from the [duckdb](https://r.duckdb.org)-package\n\namong others, we will focus on the [fread()](https://rdatatable.gitlab.io/data.table/reference/fread.html) from the [data.table](https://rdatatable.gitlab.io/data.table/index.html)-package as it delivers quite an extraordinary performance. The other functions would offer you the same functionality, maybe with a different syntax.\n\nOur csv-file may look like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclient_number,fromDate,toDate,toPayPerMonth\n\"001\",2025-01-01,2025-05-01,1.23\n\"123\",2024-12-24,2025-02-02,2.34\n\"987654\",2025-07-05,2099-12-31,3.45\n```\n:::\n\n\nIf we read it with fread and let the function decide how to transform the columns into datatypes\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(data.table)\ndt = fread(\"./nice.csv\")\ndt\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   client_number   fromDate     toDate toPayPerMonth\n           <int>     <IDat>     <IDat>         <num>\n1:             1 2025-01-01 2025-05-01          1.23\n2:           123 2024-12-24 2025-02-02          2.34\n3:        987654 2025-07-05 2099-12-31          3.45\n```\n\n\n:::\n:::\n\n\nwe can see, that\n\n-   it correctly encoded the Dates `fromDate` and `toDate` as well as the number `toPayPerMonth`,\n\n-   but it wrongly turned the `client_number`, which we wanted to be a character (as was indicated by the leading 0 and the quotation marks around the data) into an integer type\n\n::: callout-note\nLet me mention here, that if there had been one letter in the first column, then fread would have guessed correctly to use a character-type for the column.\n:::\n\nWe could correct that with some easy data-transformations.\n\nUnfortunately our (real) csv\n\n-   is without an header\n\n-   doesn't adhere to common datatype conventions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n001,20250101,05012025,1.23\n123,20241224,02022025,2.34\n987654,20250705,12312099,3.45\n```\n:::\n\n\nFurthermore it represents dates in different formats depending on the column.\n\n# Solution\n\n## Developing a solution\n\nThe fread-function offers some options/attributes to solve this problems:\n\n-   `col.names`\n\n-   `colClasses`\n\n::: callout-note\nFor a detailed explanation of what you can do with the data.table-package please see\n\nBarrett T, Dowle M, Srinivasan A, Gorecki J, Chirico M, Hocking T, Schwendinger B, Krylov I (2025). *data.table: Extension of 'data.frame'*. R package version 1.17.99, [https://r-datatable.com](https://r-datatable.com/).\n:::\n\nA two step process (reading and post-processing) with these two attributes will give us\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndtUgly = fread(\"./ugly.csv\",\n               col.names = c(\"client_number\", \"fromDate\", \"toDate\", \"toPayPerMonth\"),\n               colClasses = c(\"character\",\"character\",\"character\",\"numeric\"))\n\ndtUgly[,':='(fromDate = as.Date(fromDate, format = \"%Y%m%d\"),\n             toDate = as.Date(toDate, format = \"%m%d%Y\"))]\n\ndtUgly\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   client_number   fromDate     toDate toPayPerMonth\n          <char>     <Date>     <Date>         <num>\n1:           001 2025-01-01 2025-05-01          1.23\n2:           123 2024-12-24 2025-02-02          2.34\n3:        987654 2025-07-05 2099-12-31          3.45\n```\n\n\n:::\n:::\n\n\nwhich is the correct solution.\n\n## Using predefined data-structures\n\nIf you are reading such a csv only once the procedure above works quite well. But if you have several different csv-files it might be tedious to program a separate function for each csv.\n\nImagine you have a function with the attributes\n\n-   `pathToCSV`\n\n-   `structureOfCSV`\n\nThe key to this function is the kind of information that you encode in `structureOfCSV`. This attribute is a data.table with the following columns:\n\n-   `names` for the column-names\n\n-   `classes` for die classes of the columns\n\n-   `dateTypes` for the format of the date-columns\n\n-   `numericFactor` for manipulations to numeric columns\n\nLet's have a look at the function\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadCSV = function(pathToCSV,\n                   structureOfCSV) {\n  # read csv\n  dt = fread(input = pathToCSV,\n             col.names = structureOfCSV$names,\n             colClasses = structureOfCSV$classes)\n  \n  # convert date-types\n  dateCols = structureOfCSV[!is.na(dateTypes),.(names, dateTypes)]\n  \n  if(nrow(dateCols) > 0) {\n    for (i in 1:nrow(dateCols)) {\n      name = dateCols[i]$names\n      dt[,(name) := as.Date(get(name),format = dateCols[i]$dateTypes)]\n    }\n  }\n  \n  # convert numeric types\n  numericCols = structureOfCSV[!is.na(numericFactor),.(names, numericFactor)]\n  \n  if(nrow(numericCols) > 0) {\n    for (i in 1:nrow(numericCols)) {\n      name = numericCols[i]$names\n      dt[,(name) := get(name) * numericCols[i]$numericFactor]\n    }\n  }\n  \n  return(dt)\n}\n```\n:::\n\n\nThe corresponding structure for our file \"ugly.csv\" would look like this\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructureOfCSV = data.table(\n  names = c(\"client_number\", \"fromDate\", \"toDate\", \"toPayPerMonth\"),\n  classes = c(\"character\",\"character\",\"character\",\"numeric\"),\n  dateTypes = c(NA_character_,\"%Y%m%d\",\"%m%d%Y\",NA_character_),\n  numericFactor = c(NA_real_,NA_real_,NA_real_,NA_real_)\n)\n```\n:::\n\n\nLet's see how it can all work together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntbl = readCSV(\"./ugly.csv\",\n              structureOfCSV)\n\ntbl\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   client_number   fromDate     toDate toPayPerMonth\n          <char>     <Date>     <Date>         <num>\n1:           001 2025-01-01 2025-05-01          1.23\n2:           123 2024-12-24 2025-02-02          2.34\n3:        987654 2025-07-05 2099-12-31          3.45\n```\n\n\n:::\n:::\n\n\nand it will do the trick.\n\n::: callout-tip\nTo go even further you would have a repository of different structureOfCSV-objects - one for each kind of csv-file you have to read.\n\nYou cold even build some wrapper-functions around `readCSV` which use just the predefined structure. Imagine you have the structures `structureofCSV1` and `structureOfCSV2`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstructureOfCSV1 = data.table(\n  names = c(\"client_number\", \"fromDate\"),\n  classes = c(\"character\",\"character\"),\n  dateTypes = c(NA_character_,\"%Y%m%d\"),\n  numericFactor = c(NA_real_,NA_real_)\n)\n\nstructureOfCSV2 = data.table(\n  names = c(\"client_number\", \"toDate\", \"toPayPerMonth\"),\n  classes = c(\"character\",\"character\",\"numeric\"),\n  dateTypes = c(NA_character_,\"%m%d%Y\",NA_character_),\n  numericFactor = c(NA_real_,NA_real_,NA_real_)\n)\n```\n:::\n\n\nYou would then build the following functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\nreadCSV1 = function(pathToCSV) {\n  readCSV(pathToCSV = pathToCSV,\n          structureOfCSV = structureOfCSV1)\n}\n\nreadCSV2 = function(pathToCSV) {\n  readCSV(pathToCSV = pathToCSV,\n          structureOfCSV = structureOfCSV2)\n}\n\n# usage\n#dt1 = readCSV1(\"insert path here\")\n#dt2 = readCSV2(\"insert path here\")\n```\n:::\n\n:::\n\n::: callout-note\nWe didn't use the option of `numericFactor` as our csv had a decimal point. You would have used this option if the values are in cent instead of dollar/euro.\n\nYou could also expand the functionality of readCSV further by providing columns in structureOfCSV such as\n\n-   rounding, to round numbers\n\n-   split.character, to split a character column into several columns containing different informations\n\n-   etc.\n:::\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}